
---

## Общая архитектура

1. **Flight Search & Booking Service**  
   Отвечает за поиск рейсов и процессы создания/управления бронированием.

2. **Payment Service**  
   Обрабатывает платежи и возвраты (refunds).

3. **Loyalty Service**  
   Управляет программой лояльности (начисление и списание баллов).

4. **Admin Service**  
   Предоставляет административный функционал управления расписанием рейсов, бронированиями и пользователями.

Каждый сервис имеет собственную базу данных (для микросервисной архитектуры это считается «идеальным» вариантом).  
Коммуникация между микросервисами:
- **Kafka** для публикации и подписки на события (например, «BookingCreatedEvent», «PaymentCompletedEvent» и т.д.).
- **Feign** для прямых запросов (например, при уточнении статуса платежа или при интеграции с внешними системами).

### Основные потоки данных

1. Клиент ищет рейсы в **Flight Search & Booking Service**.
2. Клиент оформляет бронирование (Booking). Сервис:
    - Создаёт запись в своей БД.
    - Публикует событие «BookingCreatedEvent» в Kafka.
3. **Payment Service** ловит событие «BookingCreatedEvent», запрашивает у **Flight Search & Booking Service** детали бронирования через Feign (при необходимости), производит платёж и:
    - Сохраняет платёж в своей БД.
    - Публикует «PaymentCompletedEvent» (или «PaymentFailedEvent»).
4. **Flight Search & Booking Service** обновляет статус бронирования по событию «PaymentCompletedEvent» (через Kafka).
5. **Loyalty Service** при получении «PaymentCompletedEvent» начисляет (или списывает) баллы и сохраняет изменения в своей БД.
6. **Admin Service** взаимодействует со всеми сервисами (по Kafka/Feign) для управления расписанием, бронированием и формирования отчётов.

---

## 1. Flight Search & Booking Service

**Основная функциональность**:
- Поиск рейсов по критериям (дата, пункт вылета, пункт прилёта, число пассажиров и т.д.).
- Создание бронирования (booking).
- Изменение и отмена бронирования.
- Получение деталей бронирования.
- Управление местами и статусом билета (при взаимодействии с **Admin Service**).

### Эндпоинты

Все эндпоинты могут, к примеру, быть доступны по префиксу:
```
/api/v1/bookings
```
(или `/api/v1/flights`, если речь о поиске).

1. **GET /api/v1/flights**
    - **Описание**: получить список всех доступных рейсов (по умолчанию без фильтров или с базовыми параметрами).
    - **Параметры запроса** (query params, опционально): `origin`, `destination`, `dateFrom`, `dateTo`, `passengersCount` и т.д.
    - **Ответ**: список объектов `Flight` в формате JSON.

2. **POST /api/v1/flights/search**
    - **Описание**: расширенный поиск рейсов с большим количеством критериев.
    - **Тело запроса**: объект `FlightSearchCriteria` (поля для города вылета, прилёта, диапазонов дат, кол-ва пассажиров, класса обслуживания и т.д.).
    - **Ответ**: список объектов `Flight` в формате JSON, подходящих под критерии поиска.

3. **POST /api/v1/bookings**
    - **Описание**: создать новое бронирование.
    - **Тело запроса**: объект `BookingRequest` c информацией о рейсе(ах), пассажирах, предпочитаемых местах и т.п.
    - **Ответ**: объект `BookingResponse` с уникальным идентификатором бронирования (`bookingId`) и текущим статусом (например, `PENDING_PAYMENT`).
    - **Действие**:
        1. Сохранить бронирование в БД (со статусом «PENDING_PAYMENT»).
        2. Опубликовать событие `BookingCreatedEvent` в Kafka.

4. **GET /api/v1/bookings/{bookingId}**
    - **Описание**: получить детали конкретного бронирования.
    - **Ответ**: подробная информация об объекте `Booking`.

5. **PUT /api/v1/bookings/{bookingId}**
    - **Описание**: изменить (обновить) бронирование (например, смена даты вылета, пассажиров и т. д.).
    - **Тело запроса**: объект с обновлёнными полями (допустим, `BookingUpdateRequest`).
    - **Ответ**: обновлённый объект `Booking`.
    - **Действие**: в случае критических изменений (например, смены рейса, требующей перерасчёта), можно опубликовать в Kafka событие `BookingUpdatedEvent`.

6. **DELETE /api/v1/bookings/{bookingId}**
    - **Описание**: отменить бронирование (при условии, что оно не оплачено или что правила аннуляции это допускают).
    - **Ответ**: подтверждение отмены (или ошибка, если отменить нельзя).
    - **Действие**: опубликовать событие `BookingCancelledEvent` (если применяется политика возврата или удержания средств).

### Структура БД (пример)

Ниже приводится пример реализации таблиц в реляционной БД (MySQL/PostgreSQL), оформленных в Markdown-формате для удобства чтения.

#### Таблица `flights`

| Поле             | Тип           | Описание                              |
|------------------|---------------|---------------------------------------|
| **flight_id**    | BIGINT (PK)   | Уникальный идентификатор рейса        |
| origin           | VARCHAR(50)   | Пункт вылета                          |
| destination      | VARCHAR(50)   | Пункт прилёта                         |
| departure_time   | TIMESTAMP     | Время вылета                          |
| arrival_time     | TIMESTAMP     | Время прилёта                         |
| available_seats  | INT           | Количество доступных мест            |
| price            | DECIMAL(10,2) | Базовая стоимость билета             |

#### Таблица `bookings`

| Поле                  | Тип           | Описание                                                  |
|-----------------------|---------------|-----------------------------------------------------------|
| **booking_id** (PK)   | BIGINT        | Уникальный идентификатор бронирования                    |
| flight_id (FK)        | BIGINT        | Ссылка на рейс                                           |
| user_id               | BIGINT        | Идентификатор клиента (пользователя)                     |
| status                | VARCHAR(20)   | Текущий статус (PENDING_PAYMENT, CONFIRMED, CANCELLED)   |
| created_at            | TIMESTAMP     | Дата и время создания бронирования                       |
| updated_at            | TIMESTAMP     | Дата и время последнего изменения                        |
| total_price           | DECIMAL(10,2) | Итоговая стоимость бронирования                          |
| ... дополнительные поля ... | ...     | (кол-во пассажиров, класс обслуживания и т.д.)           |

#### Таблица `passengers` (опционально)

| Поле                  | Тип           | Описание                                      |
|-----------------------|---------------|-----------------------------------------------|
| **passenger_id** (PK) | BIGINT       | Уникальный идентификатор пассажира            |
| booking_id (FK)       | BIGINT        | Ссылка на бронирование                        |
| full_name             | VARCHAR(100)  | Имя и фамилия                                 |
| document_number       | VARCHAR(50)   | Номер документа (паспорт и т.д.)             |
| seat                  | VARCHAR(10)   | Место (опционально)                          |
| ...                   | ...           | Доп. поля по необходимости                    |

---

## 2. Payment Service

**Основная функциональность**:
- Получение событий о новых бронированиях.
- Проведение оплаты.
- Обработка возвратов/отмен платежей.
- Генерация транзакционных данных.

### Эндпоинты

Все эндпоинты могут быть доступны по префиксу:
```
/api/v1/payments
```

1. **POST /api/v1/payments**
    - **Описание**: инициировать платёж по бронированию.
    - **Тело запроса**: `PaymentRequest` (содержит `bookingId`, сумму, платёжные данные и т.д.).
    - **Ответ**: объект `PaymentResponse` (статус платежа, идентификатор транзакции).
    - **Действие**:
        1. Сохранить в своей БД запись о платеже со статусом «PROCESSING».
        2. Попробовать провести платёж (обратиться к внешнему платёжному шлюзу или смоделировать).
        3. По результату обновить статус (COMPLETED / FAILED).
        4. Опубликовать `PaymentCompletedEvent` или `PaymentFailedEvent` в Kafka.

2. **GET /api/v1/payments/{paymentId}**
    - **Описание**: получить детали конкретного платежа.
    - **Ответ**: JSON со всей информацией о платеже (статус, сумма, дата, метод оплаты и т.д.).

3. **POST /api/v1/payments/refund**
    - **Описание**: инициировать возврат денежных средств (refund) по уже оплаченному бронированию.
    - **Тело запроса**: `RefundRequest` (содержит `paymentId`, причину возврата и т.п.).
    - **Ответ**: `RefundResponse` (статус, идентификатор операции).
    - **Действие**:
        1. Проверить статус исходного платежа.
        2. Инициировать процесс возврата.
        3. При успехе опубликовать `RefundCompletedEvent` в Kafka (может пригодиться для обновления бронирования/статуса в Loyalty Service).

### Структура БД (пример)

#### Таблица `payments`

| Поле                | Тип           | Описание                                               |
|---------------------|---------------|--------------------------------------------------------|
| **payment_id** (PK) | BIGINT        | Уникальный идентификатор платежа                       |
| booking_id          | BIGINT        | Ссылка на бронирование                                 |
| amount              | DECIMAL(10,2) | Сумма платежа                                          |
| status              | VARCHAR(20)   | Статус (PROCESSING, COMPLETED, FAILED, REFUNDED)       |
| payment_method      | VARCHAR(50)   | Метод оплаты (Visa, MasterCard, PayPal и т.д.)         |
| created_at          | TIMESTAMP     | Дата и время создания платежа                          |
| updated_at          | TIMESTAMP     | Дата и время обновления платежа                        |

#### Таблица `refunds` (при необходимости)

| Поле               | Тип           | Описание                                              |
|--------------------|---------------|-------------------------------------------------------|
| **refund_id** (PK) | BIGINT        | Уникальный идентификатор возврата                     |
| payment_id (FK)    | BIGINT        | Ссылка на платеж                                     |
| amount             | DECIMAL(10,2) | Сумма возврата                                       |
| status             | VARCHAR(20)   | Статус возврата (INITIATED, COMPLETED, FAILED)        |
| reason             | VARCHAR(255)  | Причина возврата                                     |
| created_at         | TIMESTAMP     | Дата и время инициации возврата                       |

---

## 3. Loyalty Service

**Основная функциональность**:
- Регистрация/учёт участников программы лояльности.
- Начисление и списание баллов.
- Просмотр баланса баллов клиентом.
- Интеграция с другими сервисами при оплате/возвратах.

### Эндпоинты

Все эндпоинты могут быть доступны по префиксу:
```
/api/v1/loyalty
```

1. **POST /api/v1/loyalty/register**
    - **Описание**: зарегистрировать нового пользователя в программе лояльности.
    - **Тело запроса**: `LoyaltyRegisterRequest` (содержит `userId`, личные данные и т.д.).
    - **Ответ**: `LoyaltyRegisterResponse` (подтверждение регистрации, начальный баланс).

2. **GET /api/v1/loyalty/points/{userId}**
    - **Описание**: получить текущий баланс баллов для указанного пользователя.
    - **Ответ**: число баллов или объект с подробной информацией о счёте.

3. **POST /api/v1/loyalty/accrue**
    - **Описание**: начислить баллы по событию успешной оплаты.
    - **Тело запроса**: `LoyaltyAccrualRequest` (включает `userId`, `amount`, `bookingId` и др. детали).
    - **Ответ**: новый баланс или подтверждение операции.
    - **Действие**: обновить баланс баллов в БД, сохранить транзакцию «начисление баллов».

4. **POST /api/v1/loyalty/spend**
    - **Описание**: списать баллы при оплате баллами (если такая функция доступна).
    - **Тело запроса**: `LoyaltySpendRequest`.
    - **Ответ**: обновлённый баланс или подтверждение операции.

### Структура БД (пример)

#### Таблица `loyalty_accounts`

| Поле                  | Тип         | Описание                                               |
|-----------------------|------------ |--------------------------------------------------------|
| **loyalty_id** (PK)   | BIGINT      | Уникальный идентификатор аккаунта в лояльности         |
| user_id               | BIGINT      | Ссылка на пользователя                                 |
| balance               | INT         | Текущий баланс баллов                                  |
| created_at            | TIMESTAMP   | Дата и время создания                                  |
| updated_at            | TIMESTAMP   | Дата и время последнего изменения                     |

#### Таблица `loyalty_transactions`

| Поле                       | Тип           | Описание                                                         |
|----------------------------|---------------|------------------------------------------------------------------|
| **transaction_id** (PK)    | BIGINT        | Уникальный идентификатор транзакции                              |
| loyalty_id (FK)            | BIGINT        | Ссылка на аккаунт лояльности                                     |
| booking_id (опц.)          | BIGINT        | Ссылка на бронирование (если начисление/списание связано с ним)  |
| change_amount              | INT           | На сколько баллов изменился баланс                               |
| type (ACCRUE/SPEND/...)    | VARCHAR(10)   | Тип операции (начисление, списание и т.д.)                       |
| created_at                 | TIMESTAMP     | Дата и время совершения операции                                 |

---

## 4. Admin Service

**Основная функциональность**:
- Управление расписанием рейсов (CRUD-операции над рейсами).
- Управление бронированиями (просмотр, принудительная отмена, изменение статуса).
- Управление пользователями (подтверждение, блокировка и т.д.).
- Формирование отчётов (общее количество бронирований, поступивших платежей, количество начисленных баллов и т.п.).

### Эндпоинты

Доступны по префиксу:
```
/api/v1/admin
```

1. **POST /api/v1/admin/flights**
    - **Описание**: создать новый рейс.
    - **Тело запроса**: `FlightCreateRequest`.
    - **Ответ**: созданный объект `Flight`.

2. **PUT /api/v1/admin/flights/{flightId}**
    - **Описание**: обновить информацию о рейсе (время вылета/прилёта, цена, доступные места и т.д.).
    - **Ответ**: обновлённый объект `Flight`.

3. **DELETE /api/v1/admin/flights/{flightId}**
    - **Описание**: удалить (деактивировать) рейс.
    - **Ответ**: подтверждение операции или ошибка, если рейс нельзя удалить (например, уже есть бронирования).

4. **GET /api/v1/admin/bookings**
    - **Описание**: получить список всех бронирований с фильтрами (по статусу, дате создания и т.д.).
    - **Ответ**: список объектов `Booking`.

5. **PUT /api/v1/admin/bookings/{bookingId}/status**
    - **Описание**: принудительно изменить статус бронирования (например, «CANCELLED», если клиент обратился в поддержку).
    - **Тело запроса**: объект, содержащий новый статус и причину изменения.
    - **Ответ**: обновлённый объект `Booking`.

6. **GET /api/v1/admin/users**
    - **Описание**: получить список пользователей (клиентов, админов и т.д.).
    - **Ответ**: список объектов `User`.

7. **PUT /api/v1/admin/users/{userId}**
    - **Описание**: изменить статус пользователя (активировать, заблокировать и т.д.).

8. **GET /api/v1/admin/reports**
    - **Описание**: получить разные метрики и отчёты (кол-во бронирований за период, сумма платежей, активность лояльности и т.д.).
    - **Параметры**: период отчёта (`dateFrom`, `dateTo`), тип отчёта.
    - **Ответ**: JSON с агрегированными данными (при необходимости можно отдавать CSV-файл, PDF и т.д.).

### Структура БД (пример)

У **Admin Service** может быть своя таблица пользователей или он может по Feign ходить в отдельный сервис Users (если бы он был). Но в нашем случае можно предположить, что управление пользователями (учётными записями) находится в этом сервисе.

#### Таблица `users`

| Поле              | Тип          | Описание                               |
|-------------------|--------------|----------------------------------------|
| **user_id** (PK)  | BIGINT       | Уникальный идентификатор пользователя  |
| email             | VARCHAR(100) | Email пользователя                     |
| password_hash     | VARCHAR(255) | Хэш пароля                             |
| role              | VARCHAR(50)  | Роль (ADMIN, CLIENT, и т.д.)           |
| status            | VARCHAR(20)  | Активен, заблокирован и т.д.           |
| created_at        | TIMESTAMP    | Дата создания аккаунта                 |

Для рейсов можно использовать ту же таблицу `flights`, что и в **Flight Search & Booking Service**, но по «чистой» микросервисной идеологии у Admin Service должна быть собственная копия данных либо возможности администрировать непосредственно через API **FlightService** (т. е. **AdminService** может вызывать **FlightService** по Feign).

При желании можно хранить историю админ-действий:

#### Таблица `admin_actions_log`

| Поле              | Тип         | Описание                                                      |
|-------------------|------------ |---------------------------------------------------------------|
| **action_id** (PK)| BIGINT      | Уникальный идентификатор записи                               |
| admin_id (FK)     | BIGINT      | Администратор, совершивший действие                           |
| action_type       | VARCHAR(50) | Тип действия (CREATE_FLIGHT, CANCEL_BOOKING, UPDATE_USER ...) |
| details           | TEXT        | Подробное описание действия                                   |
| created_at        | TIMESTAMP   | Время совершения                                             |

---

## Использование Kafka

Для асинхронного взаимодействия между микросервисами определим несколько **topics**:

- **booking-topic**: для событий, связанных с бронированием (BookingCreatedEvent, BookingUpdatedEvent, BookingCancelledEvent).
- **payment-topic**: для событий, связанных с платежами (PaymentCompletedEvent, PaymentFailedEvent, RefundCompletedEvent).
- **loyalty-topic**: для событий лояльности (LoyaltyAccruedEvent и т.п., при желании).

Каждый сервис:
- **Flight Search & Booking Service** публикует `BookingCreatedEvent` в `booking-topic`. Слушает `PaymentCompletedEvent` (обновляет статус бронирования).
- **Payment Service** слушает `BookingCreatedEvent`, обрабатывает оплату и публикует `PaymentCompletedEvent`.
- **Loyalty Service** слушает `PaymentCompletedEvent` и на его основании начисляет баллы.
- **Admin Service** может слушать все события для формирования отчётов.

---

## Использование Feign

- **Flight Search & Booking Service** может дергать **Payment Service** по Feign, если необходимо синхронно инициализировать оплату или получить статус.
- **Payment Service** может дергать **Flight Search & Booking Service** по Feign, если нужно подтянуть детали бронирования.
- **Loyalty Service** может дергать **Flight Search & Booking Service** или **Payment Service** для валидации данных, если бизнес-логика этого требует.
- **Admin Service** может дергать **Flight Search & Booking Service** и **Payment Service** для просмотра данных о бронированиях и платежах.

---

## Нефункциональные требования

1. **Безопасность**
    - Использовать механизмы аутентификации и авторизации (например, OAuth2 или JWT).
    - Защита API через Spring Security.
    - Шифрование конфиденциальных данных (внешние платёжные данные и т. п.).

2. **Масштабируемость**
    - Возможность горизонтального масштабирования каждого микросервиса.
    - Kafka-кластер для надёжности (минимум 3 брокера).

3. **Устойчивость и отказоустойчивость**
    - Использовать механизмы retry, circuit breaker (Spring Cloud Circuit Breaker/Resilience4j).
    - Настроить health-check endpoints для каждого сервиса (/actuator/health).

4. **Отчётность**
    - **Admin Service** должен формировать отчёты (кол-во бронирований, сумма платежей, начисленные/списанные баллы и т.д.).
    - Возможен экспорт отчётов в CSV, Excel, PDF.

5. **Логгирование и аудит**
    - Логгировать ключевые события (создание бронирования, успешная/неуспешная оплата, начисление баллов и т.д.).
    - Для админских операций вести аудит действий (создание/удаление рейсов, принудительная отмена бронирований).
